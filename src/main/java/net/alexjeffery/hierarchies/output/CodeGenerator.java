package net.alexjeffery.hierarchies.output;

import net.alexjeffery.hierarchies.syntax.Declaration;
import net.alexjeffery.hierarchies.syntax.Field;
import net.alexjeffery.hierarchies.visitor.DeclarationVisitor;
import org.antlr.v4.runtime.misc.NotNull;

import java.util.List;
import java.util.function.BiConsumer;

public class CodeGenerator {

    public String genDeclaration(@NotNull Declaration declaration) {
        return declaration.accept(GenDeclarationVisitor.INSTANCE, null);
    }

    private static class GenDeclarationVisitor extends DeclarationVisitor<Void, String, RuntimeException> {

        private GenDeclarationVisitor() { }

        public static final GenDeclarationVisitor INSTANCE = new GenDeclarationVisitor();

        @NotNull
        public String visit(@NotNull Declaration.Fixed fixed, Void input) throws RuntimeException {
            StringBuilder builder = new StringBuilder();
            // class header
            builder.append("/* Generated by Hierarchies. Edits will be lost. */\n");
            builder.append("public class " + fixed.name + " {\n    ");
            // field declarations
            appendFieldsFormatted(GenDeclarationVisitor::appendFieldDeclaration, fixed.fields, builder, "");
            // constructor header
            builder.append("public " + fixed.name + "(");
            appendFieldsFormatted(GenDeclarationVisitor::appendConstructorParameter,
                    fixed.fields, builder, ", ");
            builder.append(") {\n        ");
            // constructor body
            appendFieldsFormatted(GenDeclarationVisitor::appendConstructorAssignment,
                    fixed.fields, builder, "\n        ");
            builder.append("\n    }");
            // getters and setters
            appendFieldsFormatted(GenDeclarationVisitor::appendGetter,
                    fixed.fields, builder, "\n");
            appendFieldsFormatted(GenDeclarationVisitor::appendSetter,
                    fixed.fields, builder, "\n");
            // end of class
            builder.append("\n}");
            return builder.toString();
        }

        private static void appendFieldDeclaration(@NotNull Field field, @NotNull StringBuilder builder) {
            appendIsOptional(field, builder);
            builder.append("\n    private ");
            appendType(field, builder);
            builder.append(" " + field.name);
            builder.append(";\n    ");
        }

        private static void appendConstructorParameter(@NotNull Field field, @NotNull StringBuilder builder) {
            appendIsOptional(field, builder);
            builder.append(" ");
            appendType(field, builder);
            builder.append(" " + field.name);
        }

        private static void appendConstructorAssignment(@NotNull Field field, @NotNull StringBuilder builder) {
            String name = field.name;
            builder.append("this.");
            builder.append(name);
            builder.append(" = ");
            builder.append(name);
            builder.append(";");
        }

        private static void appendGetter(@NotNull Field field, @NotNull StringBuilder builder) {
            appendIsOptional(field, builder);
            builder.append("\n    public ");
            appendType(field, builder);
            builder.append(" get");
            appendNameCapitalised(field, builder);
            builder.append("() {\n        return this.");
            builder.append(field.name);
            builder.append(";\n    }");
        }

        private static void appendSetter(@NotNull Field field, @NotNull StringBuilder builder) {
            builder.append("\n    public void set");
            appendNameCapitalised(field, builder);
            builder.append("(");
            appendIsOptional(field, builder);
            builder.append(" ");
            appendType(field, builder);
            builder.append(" ");
            builder.append(field.name);
            builder.append(") {\n        this.");
            builder.append(field.name);
            builder.append(" = ");
            builder.append(field.name);
            builder.append(";\n    }");
        }

        private static void appendFieldsFormatted(
                @NotNull BiConsumer<Field, StringBuilder> action,
                @NotNull List<Field> fields,
                @NotNull StringBuilder builder,
                @NotNull String intersperseText) {
            if (fields.isEmpty())
                return;
            appendFieldFormatted(action, fields.get(0), builder);
            for (int i = 1; i < fields.size(); i++) {
                builder.append(intersperseText);
                appendFieldFormatted(action, fields.get(i), builder);
            }
        }

        private static void appendFieldFormatted(
                @NotNull BiConsumer<Field, StringBuilder> action,
                @NotNull Field field,
                @NotNull StringBuilder builder) {
            action.accept(field, builder);
        }

        public static void appendIsOptional(@NotNull Field field, @NotNull StringBuilder builder) {
            builder.append(field.isOptional ? "@Nullable" : "@NotNull");
        }

        public static void appendType(@NotNull Field field, @NotNull StringBuilder builder) {
            boolean isList = field.isList;
            builder.append(isList ? "List<" : "");
            builder.append(field.type);
            builder.append(isList ? ">" : "");
        }

        public static void appendNameCapitalised(@NotNull Field field, @NotNull StringBuilder builder) {
            builder.append(Character.toUpperCase(field.name.charAt(0)));
            builder.append(field.name.substring(1));
        }

        @NotNull
        public String visit(@NotNull Declaration.Options options, Void input) throws RuntimeException {
            return "";
        }
    }


}
