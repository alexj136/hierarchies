package net.alexjeffery.hierarchies.output;

import net.alexjeffery.hierarchies.syntax.Declaration;
import net.alexjeffery.hierarchies.syntax.Field;
import net.alexjeffery.hierarchies.syntax.Option;
import net.alexjeffery.hierarchies.util.Pair;
import net.alexjeffery.hierarchies.util.ThrowingConsumer;
import net.alexjeffery.hierarchies.visitor.DeclarationVisitor;
import org.antlr.v4.runtime.misc.NotNull;
import org.antlr.v4.runtime.misc.Nullable;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

public class CodeGenerator {

    private static final String HEADER =
            "import org.antlr.v4.runtime.misc.NotNull;\n" +
            "import org.antlr.v4.runtime.misc.Nullable;\n" +
            "\n" +
            "import java.util.List;\n" +
            "\n" +
            "/* Generated by Hierarchies. Edits will be lost. */\n";

    @NotNull
    public static List<Pair<String, Appendable>> genDeclaration(
            @NotNull Supplier<Appendable> bufferSupplier,
            @NotNull Declaration declaration
    ) throws IOException {
        return declaration.accept(GenDeclarationVisitor.INSTANCE, bufferSupplier);
    }

    private static class GenDeclarationVisitor
            extends DeclarationVisitor<Supplier<Appendable>, List<Pair<String, Appendable>>, IOException> {

        private GenDeclarationVisitor() { }

        public static final GenDeclarationVisitor INSTANCE = new GenDeclarationVisitor();

        @NotNull
        public List<Pair<String, Appendable>> visit(
                @NotNull Declaration.Fixed fixed,
                @NotNull Supplier<Appendable> bufferSupplier
        ) throws IOException {
            List<Pair<String, Appendable>> output = new ArrayList<>();
            Appendable buffer = bufferSupplier.get();
            ConcreteClassGenerator.generate(buffer, fixed.fields, fixed.name);
            output.add(Pair.of(fixed.name, buffer));
            return output;
        }

        @NotNull
        public List<Pair<String, Appendable>> visit(
                @NotNull Declaration.Options options,
                @NotNull Supplier<Appendable> bufferSupplier
        ) throws IOException {
            List<Pair<String, Appendable>> output = new ArrayList<>();

            Appendable buffer = bufferSupplier.get();
            generateAbstractClass(buffer, options.name);
            output.add(Pair.of(options.name, buffer));

            buffer = bufferSupplier.get();
            generateVisitorClass(buffer, options);
            output.add(Pair.of(options.name + "Visitor", buffer));

            for (Option option : options.options) {
                buffer = bufferSupplier.get();
                ConcreteClassGenerator.generate(buffer, option.fields, option.name, options.name);
                output.add(Pair.of(option.name, buffer));
            }

            return output;
        }
    }

    @NotNull
    private static void generateAbstractClass(
            @NotNull Appendable buffer,
            @NotNull String superName
    ) throws IOException {
        buffer.append(HEADER)
                .append("public abstract class ")
                .append(superName)
                .append(" {\n\n    public <I, O, X extends Throwable> O accept(@NotNull ")
                .append(superName)
                .append("Visitor<I, O, X> visitor, I input) throws X {\n        return null;\n    }\n}\n");
    }

    @NotNull
    private static void generateVisitorClass(
            @NotNull Appendable buffer,
            @NotNull Declaration.Options options
    ) throws IOException{
        buffer.append(HEADER)
                .append("public abstract class ")
                .append(options.name)
                .append("Visitor<I, O, X extends Throwable> {\n\n    ");
        ThrowingConsumer.consumeListWithIntermediateAction(
                option -> appendVisitMethod(buffer, option.name),
                options.options,
                __ -> buffer.append("\n\n    "));
        buffer.append("\n}\n").toString();
    }

    private static void appendVisitMethod(
            @NotNull Appendable buffer,
            @NotNull String subclassName
    ) throws IOException {
        buffer.append("public O visit(@NotNull ")
                .append(subclassName)
                .append(" ");
        appendSubclassNameUncapitalised(buffer, subclassName);
        buffer.append(", I input) throws X {\n        return null;\n    }");
    }

    private static void appendSubclassNameUncapitalised(
            @NotNull Appendable buffer,
            @NotNull String subclassName
    ) throws IOException {
        buffer.append(Character.toLowerCase(subclassName.charAt(0)));
        buffer.append(subclassName.substring(1));
    }

    private static class ConcreteClassGenerator {

        public static void generate(
                @NotNull Appendable buffer,
                @NotNull List<Field> fields,
                @NotNull String name
        ) throws IOException {
            ConcreteClassGenerator.generate(buffer, fields, name, null);
        }

        public static void generate(
                @NotNull Appendable buffer,
                @NotNull List<Field> fields,
                @NotNull String name,
                @Nullable String superName
        ) throws IOException {
            ConcreteClassGenerator generator = new ConcreteClassGenerator(buffer);
            generator.appendClass(fields, name, superName);
        }

        @NotNull
        private Appendable buffer;

        private ConcreteClassGenerator(@NotNull Appendable buffer) {
            this.buffer = buffer;
        }

        @NotNull
        private void appendClass(
                @NotNull List<Field> fields,
                @NotNull String name,
                @Nullable String superName
        ) throws IOException {
            buffer.append(HEADER);
            buffer.append("public class ").append(name);
            if (superName != null)
                buffer.append(" extends ").append(superName);
            buffer.append(" {\n\n");
            appendFieldsFormatted(this::appendFieldDeclaration, fields, "");
            buffer.append("\n    public ").append(name).append("(");
            appendFieldsFormatted(this::appendConstructorParameter, fields, ", ");
            buffer.append(") {\n        ");
            appendFieldsFormatted(this::appendConstructorAssignment, fields, "\n        ");
            buffer.append("\n    }\n");
            appendFieldsFormatted(this::appendGetter, fields, "\n");
            buffer.append("\n");
            appendFieldsFormatted(this::appendSetter, fields, "\n");
            if (superName != null) {
                buffer.append("\n\n");
                appendAcceptMethod(superName);
            }
            buffer.append("\n}\n");
        }

        private void appendFieldDeclaration(@NotNull Field field) throws IOException {
            buffer.append("    ");
            appendIsOptional(field);
            buffer.append("\n    private ");
            appendType(field);
            buffer.append(" ").append(field.name);
            buffer.append(";\n");
        }

        private void appendConstructorParameter(@NotNull Field field) throws IOException {
            appendIsOptional(field);
            buffer.append(" ");
            appendType(field);
            buffer.append(" ").append(field.name);
        }

        private void appendConstructorAssignment(@NotNull Field field) throws IOException {
            String name = field.name;
            buffer.append("this.");
            buffer.append(name);
            buffer.append(" = ");
            buffer.append(name);
            buffer.append(";");
        }

        private void appendGetter(@NotNull Field field) throws IOException {
            buffer.append("\n    ");
            appendIsOptional(field);
            buffer.append("\n    public ");
            appendType(field);
            buffer.append(" get");
            appendFieldNameCapitalised(field);
            buffer.append("() {\n        return this.");
            buffer.append(field.name);
            buffer.append(";\n    }");
        }

        private void appendSetter(@NotNull Field field) throws IOException {
            buffer.append("\n    public void set");
            appendFieldNameCapitalised(field);
            buffer.append("(");
            appendIsOptional(field);
            buffer.append(" ");
            appendType(field);
            buffer.append(" ");
            buffer.append(field.name);
            buffer.append(") {\n        this.");
            buffer.append(field.name);
            buffer.append(" = ");
            buffer.append(field.name);
            buffer.append(";\n    }");
        }


        private void appendAcceptMethod(@NotNull String superName) throws IOException {
            buffer.append("    @Override\n")
                    .append("    public <I, O, X extends Throwable> O accept(@NotNull ")
                    .append(superName)
                    .append("Visitor<I, O, X> visitor, I input) throws X {\n")
                    .append("        return visitor.visit(this, input);\n")
                    .append("    }");
        }

        private void appendFieldsFormatted(
                @NotNull ThrowingConsumer<Field, IOException> action,
                @NotNull List<Field> fields,
                @NotNull String intersperseText)
                throws IOException {
            ThrowingConsumer.consumeListWithIntermediateAction(action, fields, __ -> {
                buffer.append(intersperseText);
            });
        }

        private void appendIsOptional(@NotNull Field field) throws IOException {
            buffer.append(field.isOptional ? "@Nullable" : "@NotNull");
        }

        private void appendType(@NotNull Field field) throws IOException {
            boolean isList = field.isList;
            buffer.append(isList ? "List<" : "");
            buffer.append(field.type);
            buffer.append(isList ? ">" : "");
        }

        private void appendFieldNameCapitalised(@NotNull Field field) throws IOException {
            buffer.append(Character.toUpperCase(field.name.charAt(0)));
            buffer.append(field.name.substring(1));
        }
    }
}
